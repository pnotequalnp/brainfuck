-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Brainfuck Compiler and Interpreter
--   
--   Configurable interpreter and optimizing compiler for the brainfuck
--   language using LLVM as a backend.
@package brainfuck
@version 0.6.0.0


module Brainfuck.Configuration

-- | Settings for brainfuck runtime behavior
data RuntimeSettings
RuntimeSettings :: Word64 -> Word64 -> EofBehavior -> RuntimeSettings

-- | Number of memory cells available
[memory] :: RuntimeSettings -> Word64

-- | Initial location of the pointer
[initialPointer] :: RuntimeSettings -> Word64

-- | Behavior when the input stream has reached EOF
[eofBehavior] :: RuntimeSettings -> EofBehavior

-- | Action to take when the input stream reaches EOF
data EofBehavior

-- | Return <tt>0</tt>
Zero :: EofBehavior

-- | Leave the cell unchanged
Unchanged :: EofBehavior

-- | Return <tt>-1</tt>
NegativeOne :: EofBehavior


module Brainfuck.Interpreter.IO

-- | Input function for <a>IO</a>, reading from <tt>stdin</tt>, giving
--   <tt>0</tt> for EOF
handleInput :: forall byte. (Num byte, Storable byte) => Handle -> EofBehavior -> byte -> IO byte

-- | Output function for <a>IO</a>, writing to <tt>stdout</tt>
handleOutput :: Storable byte => Handle -> byte -> IO ()


module Brainfuck.LLVM

-- | Compile an LLVM module to object code
compileLLVM :: Word -> Module -> IO ByteString

-- | Pretty print an LLVM module
showLLVM :: Word -> Module -> IO ByteString

-- | Pretty print an LLVM module
showASM :: Word -> Module -> IO ByteString

-- | Execute an LLVM module with JIT compilation
jitLLVM :: Word -> Module -> IO ()

-- | Optimize an LLVM module
optimizeLLVM :: Word -> Module -> IO Bool
fromJit :: FunPtr (IO Word32) -> IO Word32


module Brainfuck.Syntax

-- | Brainfuck language intermediate representation
data Brainfuck byte addr

-- | Add the given value to the memory cell at the given offset from the
--   pointer
Add :: byte -> addr -> Brainfuck byte addr

-- | Set the memory cell at the given offset from the pointer to the given
--   value
Set :: byte -> addr -> Brainfuck byte addr

-- | Multiply the current offset memory cell and add the result to the
--   combined offset cell
Mul :: byte -> addr -> addr -> Brainfuck byte addr

-- | Shift the pointer by some offset
Shift :: addr -> Brainfuck byte addr

-- | Input a byte into the cell at the given offset from the pointer
Input :: addr -> Brainfuck byte addr

-- | Output the byte at the given offset from the pointer
Output :: addr -> Brainfuck byte addr

-- | Execute the subprogram until the current memory cell is <tt>0</tt>
Loop :: [Brainfuck byte addr] -> Brainfuck byte addr

-- | Do nothing
Nop :: Brainfuck byte addr

-- | Increment the memory cell at the pointer
pattern Inc :: (Eq byte, Eq addr, Num byte, Num addr) => Brainfuck byte addr

-- | Decrement the memory cell at the pointer
pattern Dec :: (Eq byte, Eq addr, Num byte, Num addr) => Brainfuck byte addr

-- | Move the pointer to the left
pattern Left_ :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Move the pointer to the right
pattern Right_ :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Input a char and store it in the memory cell at the pointer
pattern In :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Output the char represented by the memory cell at the pointer
pattern Out :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Base functor for <a>Brainfuck</a>, for use with recursion schemes
data BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
AddF :: byte_adAu -> addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
SetF :: byte_adAu -> addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
MulF :: byte_adAu -> addr_adAv -> addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
ShiftF :: addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
InputF :: addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
OutputF :: addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
LoopF :: [r_aei7] -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
NopF :: BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
pattern IncF :: (Eq byte, Eq addr, Num byte, Num addr) => BrainfuckF byte addr a
pattern DecF :: (Eq byte, Eq addr, Num byte, Num addr) => BrainfuckF byte addr a
pattern LeftF_ :: (Eq addr, Num addr) => BrainfuckF byte addr a
pattern RightF_ :: (Eq addr, Num addr) => BrainfuckF byte addr a
pattern InF :: (Eq addr, Num addr) => BrainfuckF byte addr a
pattern OutF :: (Eq addr, Num addr) => BrainfuckF byte addr a
instance Data.Traversable.Traversable (Brainfuck.Syntax.BrainfuckF byte addr)
instance Data.Foldable.Foldable (Brainfuck.Syntax.BrainfuckF byte addr)
instance GHC.Base.Functor (Brainfuck.Syntax.BrainfuckF byte addr)
instance Data.Functor.Foldable.Recursive (Brainfuck.Syntax.Brainfuck byte addr)
instance Data.Functor.Foldable.Corecursive (Brainfuck.Syntax.Brainfuck byte addr)
instance (Prettyprinter.Internal.Pretty byte, Prettyprinter.Internal.Pretty addr, GHC.Classes.Eq byte, GHC.Num.Num byte, GHC.Classes.Eq addr, GHC.Num.Num addr) => Prettyprinter.Internal.Pretty (Brainfuck.Syntax.Brainfuck byte addr)
instance (GHC.Show.Show byte, GHC.Show.Show addr) => GHC.Show.Show (Brainfuck.Syntax.Brainfuck byte addr)
instance (GHC.Classes.Ord byte, GHC.Classes.Ord addr) => GHC.Classes.Ord (Brainfuck.Syntax.Brainfuck byte addr)
instance (GHC.Classes.Eq byte, GHC.Classes.Eq addr) => GHC.Classes.Eq (Brainfuck.Syntax.Brainfuck byte addr)


module Brainfuck.Parser

-- | Parse a brainfuck program from a bytestring
parse :: (Num byte, Eq byte, Num addr, Eq addr) => FilePath -> ByteString -> Either (Diagnostic String) [Brainfuck byte addr]
instance GHC.Show.Show Brainfuck.Parser.MismatchedBracket
instance GHC.Classes.Ord Brainfuck.Parser.MismatchedBracket
instance GHC.Classes.Eq Brainfuck.Parser.MismatchedBracket


module Brainfuck.Optimizer

-- | Contract chains of operations like <a>Add</a> and <tt>ShiftR</tt> into
--   single combined operations
contract :: (Num byte, Ord byte, Num addr, Ord addr) => [Brainfuck byte addr] -> [Brainfuck byte addr]

-- | Replace common loop idioms with single instructions
deloopify :: (Num byte, Eq byte, Num addr, Eq addr) => [Brainfuck byte addr] -> [Brainfuck byte addr]

-- | Avoid redundant pointer manipulation by doing operations at an offset
--   from the pointer
offsetInstructions :: (Num addr, Ord addr) => [Brainfuck byte addr] -> [Brainfuck byte addr]


module Brainfuck.LLVM.Codegen

-- | Generate an LLVM module from a brainfuck program
codegen :: forall byte addr. (Integral byte, Storable byte, Integral addr, Storable addr) => RuntimeSettings -> [Brainfuck byte addr] -> Module


module Brainfuck.Interpreter

-- | Interpret a brainfuck program
interpret :: (PrimMonad m, Num byte, Eq byte, Unbox byte, Integral addr) => (byte -> m byte) -> (byte -> m ()) -> Int -> addr -> [Brainfuck byte addr] -> m (MVector (PrimState m) byte, addr)

-- | Execute a single brainfuck instruction
execute :: (PrimMonad m, Num byte, Eq byte, Unbox byte, Integral addr) => (byte -> m byte) -> (byte -> m ()) -> MVector (PrimState m) byte -> MutVar (PrimState m) addr -> Brainfuck byte addr -> m ()


module Brainfuck.Checks

-- | Checks if the memory given is larger than the max value of the pointer
--   type or zero
memorySize :: forall addr. Storable addr => Word64 -> Maybe (Report String)

-- | Checks if the initial pointer is in bounds
initialPointerPosition :: forall addr. Storable addr => Word64 -> Maybe (Report String)

-- | Checks if any I/O is performed during the program
heatsTheBox :: [Brainfuck byte addr] -> Maybe (Report String)


module Brainfuck

-- | Brainfuck language intermediate representation
data Brainfuck byte addr

-- | Add the given value to the memory cell at the given offset from the
--   pointer
Add :: byte -> addr -> Brainfuck byte addr

-- | Set the memory cell at the given offset from the pointer to the given
--   value
Set :: byte -> addr -> Brainfuck byte addr

-- | Multiply the current offset memory cell and add the result to the
--   combined offset cell
Mul :: byte -> addr -> addr -> Brainfuck byte addr

-- | Shift the pointer by some offset
Shift :: addr -> Brainfuck byte addr

-- | Input a byte into the cell at the given offset from the pointer
Input :: addr -> Brainfuck byte addr

-- | Output the byte at the given offset from the pointer
Output :: addr -> Brainfuck byte addr

-- | Execute the subprogram until the current memory cell is <tt>0</tt>
Loop :: [Brainfuck byte addr] -> Brainfuck byte addr

-- | Do nothing
Nop :: Brainfuck byte addr

-- | Decrement the memory cell at the pointer
pattern Dec :: (Eq byte, Eq addr, Num byte, Num addr) => Brainfuck byte addr

-- | Input a char and store it in the memory cell at the pointer
pattern In :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Increment the memory cell at the pointer
pattern Inc :: (Eq byte, Eq addr, Num byte, Num addr) => Brainfuck byte addr

-- | Move the pointer to the left
pattern Left_ :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Move the pointer to the right
pattern Right_ :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Output the char represented by the memory cell at the pointer
pattern Out :: (Eq addr, Num addr) => Brainfuck byte addr

-- | Base functor for <a>Brainfuck</a>, for use with recursion schemes
data BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
AddF :: byte_adAu -> addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
SetF :: byte_adAu -> addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
MulF :: byte_adAu -> addr_adAv -> addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
ShiftF :: addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
InputF :: addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
OutputF :: addr_adAv -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
LoopF :: [r_aei7] -> BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
NopF :: BrainfuckF (byte_adAu :: Type) (addr_adAv :: Type) r_aei7
pattern IncF :: (Eq byte, Eq addr, Num byte, Num addr) => BrainfuckF byte addr a
pattern DecF :: (Eq byte, Eq addr, Num byte, Num addr) => BrainfuckF byte addr a
pattern LeftF_ :: (Eq addr, Num addr) => BrainfuckF byte addr a
pattern RightF_ :: (Eq addr, Num addr) => BrainfuckF byte addr a
pattern InF :: (Eq addr, Num addr) => BrainfuckF byte addr a
pattern OutF :: (Eq addr, Num addr) => BrainfuckF byte addr a

-- | Parse a brainfuck program from a bytestring
parse :: (Num byte, Eq byte, Num addr, Eq addr) => FilePath -> ByteString -> Either (Diagnostic String) [Brainfuck byte addr]

-- | Checks and warnings
checks :: forall byte addr. Storable addr => RuntimeSettings -> [Brainfuck byte addr] -> Maybe (Diagnostic String)

-- | Run various optimization passes in sequence
optimize :: (Num byte, Ord byte, Num addr, Ord addr) => Optimization -> Word -> [Brainfuck byte addr] -> [Brainfuck byte addr]

-- | Optimization options
data Optimization
Optimization :: Bool -> Bool -> Bool -> Optimization
[contraction] :: Optimization -> Bool
[deloopification] :: Optimization -> Bool
[offsets] :: Optimization -> Bool

-- | Contract chains of operations like <a>Add</a> and <tt>ShiftR</tt> into
--   single combined operations
contract :: (Num byte, Ord byte, Num addr, Ord addr) => [Brainfuck byte addr] -> [Brainfuck byte addr]

-- | Replace common loop idioms with single instructions
deloopify :: (Num byte, Eq byte, Num addr, Eq addr) => [Brainfuck byte addr] -> [Brainfuck byte addr]

-- | Settings for brainfuck runtime behavior
data RuntimeSettings
RuntimeSettings :: Word64 -> Word64 -> EofBehavior -> RuntimeSettings

-- | Number of memory cells available
[memory] :: RuntimeSettings -> Word64

-- | Initial location of the pointer
[initialPointer] :: RuntimeSettings -> Word64

-- | Behavior when the input stream has reached EOF
[eofBehavior] :: RuntimeSettings -> EofBehavior

-- | Action to take when the input stream reaches EOF
data EofBehavior

-- | Return <tt>0</tt>
Zero :: EofBehavior

-- | Leave the cell unchanged
Unchanged :: EofBehavior

-- | Return <tt>-1</tt>
NegativeOne :: EofBehavior

-- | Compile a brainfuck program to object code
compile :: (Integral byte, Storable byte, Integral addr, Storable addr) => RuntimeSettings -> Word -> [Brainfuck byte addr] -> IO ByteString

-- | Execute an LLVM module with JIT compilation
jitLLVM :: Word -> Module -> IO ()

-- | Compile an LLVM module to object code
compileLLVM :: Word -> Module -> IO ByteString

-- | Optimize an LLVM module
optimizeLLVM :: Word -> Module -> IO Bool

-- | Generate an LLVM module from a brainfuck program
codegen :: forall byte addr. (Integral byte, Storable byte, Integral addr, Storable addr) => RuntimeSettings -> [Brainfuck byte addr] -> Module

-- | Interpret in <a>IO</a>, reading from and writing to <tt>stdin</tt> and
--   <tt>stdout</tt>
interpretIO :: (Num byte, Eq byte, Storable byte, Unbox byte, Integral addr) => Handle -> Handle -> RuntimeSettings -> [Brainfuck byte addr] -> IO (IOVector byte, addr)

-- | Interpret a brainfuck program
interpret :: (PrimMonad m, Num byte, Eq byte, Unbox byte, Integral addr) => (byte -> m byte) -> (byte -> m ()) -> Int -> addr -> [Brainfuck byte addr] -> m (MVector (PrimState m) byte, addr)

-- | Execute a single brainfuck instruction
execute :: (PrimMonad m, Num byte, Eq byte, Unbox byte, Integral addr) => (byte -> m byte) -> (byte -> m ()) -> MVector (PrimState m) byte -> MutVar (PrimState m) addr -> Brainfuck byte addr -> m ()

-- | Pretty print brainfuck IR
showIR :: (Pretty byte, Eq byte, Num byte, Pretty addr, Eq addr, Num addr) => [Brainfuck byte addr] -> Doc ann

-- | Pretty print an LLVM module
showLLVM :: Word -> Module -> IO ByteString

-- | Pretty print an LLVM module
showASM :: Word -> Module -> IO ByteString
